m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
keepCourts
y2c
system.time({ y2c <- lapply(500:1000, getBallCourtsBall) })
y2c
courtXY
m$d
nrow(youthGeo)
courtGeo.t <- t(courtGeo)
courtGeo.t
courtGeo.t <- courtGeo.t[!is.na(courtGeo.t[,1]),]
courtXY <- data.frame(cbind(1:nrow(courtGeo.t), courtGeo.t))
rownames(courtXY) <- NULL
colnames(courtXY) <- c("c.Id", "X", "Y")
courtXy
courtXY
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
L1Dist_DegToMi(courtXY$X[c1], courtXY$Y[c1], courtXY$X[c2], courtXY$Y[c2])
}
nCourts <- nrow(courtXY)
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
# Calculate court-to-court distances
c2c.dist <- function(c1, c2){
L1Dist_DegToMi(courtXY$X[c1], courtXY$Y[c1], courtXY$X[c2], courtXY$Y[c2])
}
nCourts <- nrow(courtXY)
nCourts
c2c <- matrix(mapply(c2c.dist, rep(1:nCourts, each=nCourts), rep(1:nCourts, times=nCourts)), nrow=nCourts)
rep(1:10, times=5)
cbind(rep(1:10, times=5), rep(1:5, each=10))
y2c.dist <- function(i_yth, i_crt){
L1Dist_DegToMi(youthGeo$Long[i_yth], youthGeo$Lat[i_yth], courtXY$X[i_crt], courtXY$Y[i_crt])
}
nYouth <- nrow(youthGeo)
c2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:100, each=nCourts), rep(1:nCourts, times=100)), nrow=nYouth)
})
i_yth<- 1
i_crt <- 1
L1Dist_DegToMi(youthGeo$Long[i_yth], youthGeo$Lat[i_yth], courtXY$X[i_crt], courtXY$Y[i_crt])
youthGeo$Long[i_yth]
courtXY$X[i_crt]
youthGeo$Lat[i_yth]
youthGeo$Long[i_yth]courtGeo
courtGeo
courtGeo.t
colnames(courtXY) <- c("c.Id", "Y", "X")
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
c2c.dist <- function(c1, c2){
L1Dist_DegToMi(courtXY$X[c1], courtXY$Y[c1], courtXY$X[c2], courtXY$Y[c2])
}
nCourts <- nrow(courtXY)
c2c <- matrix(mapply(c2c.dist, rep(1:nCourts, each=nCourts), rep(1:nCourts, times=nCourts)), nrow=nCourts)
y2c.dist <- function(i_yth, i_crt){
L1Dist_DegToMi(youthGeo$Long[i_yth], youthGeo$Lat[i_yth], courtXY$X[i_crt], courtXY$Y[i_crt])
nYouth <- nrow(youthGeo)
}
nYouth <- 100
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:100, each=nCourts), rep(1:nCourts, times=100)), nrow=nYouth)
nYouth <- 100
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
})
)
nYouth <- 100
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
})
nYouth <- 1000
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
})
nYouth <- 10000
system.time({
y2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
})
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
system.time({ y2c <- lapply(1:nrow(youthGeo), getBallCourtsBall) })
nKeptsCourts
nKeptCourts
ldply(y2c, function(x) nrow(x[[1]]))
y2c[1]
y2c[[1]]
y2c
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
y2c <- lapply(1:1, getBallCourtsBall)
y2c
ixy <- 1
maxRad <- 3
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
m$d
head(courtXy)
head(courtXY)
head(youthData)
head(youthGeo)
youthGeo$Xjit <- youthGeo$Long + runif(nYouth)*(.5)*(degLong.per.mi)
youthGeo$Yjit <- youthGeo$Lat  + runif(nYouth)*(.5)*(degLat.per.mi)
summary(cbind(youthGeo$Xjit, youthGeo$Yjit))
# Load and geocode basketball court data
courtData <- read.csv("./data/raw/ball-courts.csv", header = T)
courtData <- within(courtData,
{ Address <- paste(Street.Address, City, State, sep = ", ") })
courtGeo <- sapply(courtData$Address, gGeoCode) # XXX This is returning NAs that I wouldn't expect it to. Return to this.
courtGeo.t <- t(courtGeo)
courtGeo.t <- courtGeo.t[!is.na(courtGeo.t[,1]),]
courtXY <- data.frame(cbind(1:nrow(courtGeo.t), courtGeo.t))
rownames(courtXY) <- NULL
colnames(courtXY) <- c("c.Id", "Y", "X")
# Establish city-block distance calculations
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
# Calculate court-to-court distances
c2c.dist <- function(c1, c2){
L1Dist_DegToMi(courtXY$X[c1], courtXY$Y[c1], courtXY$X[c2], courtXY$Y[c2])
}
nCourts <- nrow(courtXY)
c2c <- matrix(mapply(c2c.dist, rep(1:nCourts, each=nCourts), rep(1:nCourts, times=nCourts)), nrow=nCourts)
# Calculate youth-to-court distances ... takes too long to compute and store all (~200k*100 ~= 20m) distance combinations
#   y2c.dist <- function(i_yth, i_crt){
#     L1Dist_DegToMi(youthGeo$Long[i_yth], youthGeo$Lat[i_yth], courtXY$X[i_crt], courtXY$Y[i_crt])
#   }
#   nYouth <- nrow(youthGeo)
#   system.time({
#     y2c <- matrix(mapply(c2c.dist, rep(1:nYouth, each=nCourts), rep(1:nCourts, times=nYouth)), nrow=nYouth)
#   })
# Match youth to all courts and keep only those within a given radius (tot avoid carrying around more data than we can store)
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
y2c <- lapply(1:1, getBallCourtsBall)
y2c
youthGeo$Yjit <- youthGeo$Lat  + runif(nYouth)*(.5)*(degLat.per.mi)
degLat.per.mi
length(youthGeo$Long)
length(runif(nYouth))
summary(cbind(youthGeo$Lat, youthGeo$Long))
nYouth <- nrow(youthGeo)
nYouth
youthGeo$Xjit <- youthGeo$Long + runif(nYouth)*(.5)*(degLong.per.mi)
youthGeo$Yjit <- youthGeo$Lat  + runif(nYouth)*(.5)*(degLat.per.mi)
summary(cbind(youthGeo$Xjit, youthGeo$Yjit))
courtData <- read.csv("./data/raw/ball-courts.csv", header = T)
{ Address <- paste(Street.Address, City, State, sep = ", ") })
courtData <- within(courtData,
courtGeo.t <- t(courtGeo)
courtGeo <- sapply(courtData$Address, gGeoCode) # XXX This is returning NAs that I wouldn't expect it to. Return to this.
courtGeo.t <- courtGeo.t[!is.na(courtGeo.t[,1]),]
courtXY <- data.frame(cbind(1:nrow(courtGeo.t), courtGeo.t))
rownames(courtXY) <- NULL
colnames(courtXY) <- c("c.Id", "Y", "X")
courtData <- within(courtData, {
Address <- paste(Street.Address, City, State, sep = ", ") })
courtGeo <- sapply(courtData$Address, gGeoCode) # XXX This is returning NAs that I wouldn't expect it to. Return to this.
courtGeo.t <- t(courtGeo)
courtGeo
courtGeo.t
courtData$Address
courtGeo.t
L1Dist_DegToMi <- function(o.x, o.y, d.x, d.y){
return(abs(o.x-d.x)*(mi.per.degLong) + abs(o.y-d.y)*(mi.per.degLat))
}
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
y2c <- lapply(1:1, getBallCourtsBall)
y2c
nKeptCourts
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
y2c <- lapply(1:5, getBallCourtsBall)
nKeptCourts
nKeptCourts <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCourts <<- nKeptCourts + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d")])
}
system.time({ y2c <- lapply(1:nrow(youthGeo), getBallCourtsBall) })
nrow(c2c)
dim(c2c)
plot(courtXY$X, courtXY$Y)
nKeptCourts
nKeptCombos <- nKeptCourts
system.time({
y2c.df <- data.frame(runif(nKeptCombos*4), nrow=nKeptCombos);
# Preallocate memory for a data.frame with elements for each youth/nearby court combination, with four columns
y2c.df <- ldply(y2c, data.frame)
})
system.time({
y2c.df <- data.frame(runif(nKeptCombos*4), nrow=nKeptCombos);
# Preallocate memory for a data.frame with elements for each youth/nearby court combination, with four columns
y2c.df <- ldply(y2c, data.frame);
})
system.time( y2c.df <- ldply(y2c[1:100,], data.frame))
system.time( y2c.df <- ldply(y2c[1:100], data.frame))
y2c.df
system.time( y2c.df <- ldply(y2c[1:100], data.frame))
system.time( y2c.df <- ldply(y2c[1:1000], data.frame))
length(y2c)
system.time( y2c.df <- ldply(y2c[1:10000], data.frame))
system.time( y2c.df <- do.call("rbind", y2c[1:10000])
)
system.time( y2c.df <- do.call("rbind", y2c[1:20000]))
system.time({
y2c.df <- data.frame(runif(nKeptCombos*4), nrow=nKeptCombos);
# Preallocate memory for a data.frame with elements for each youth/nearby court combination, with four columns
y2c.df <- do.call("rbind", y2c);
})
library(plyr)
system.time({ y2c <- adply(1:100, 1, getBallCourtsBall) })
system.time({ y2c <- adply(1:1, 1, getBallCourtsBall) })
y2
y2c
system.time({ y2c <- adply(1:10, 1, getBallCourtsBall) })
system.time({ y2c <- adply(1:100, 1, getBallCourtsBall) })
system.time({ y2c <- lapply(1:100, getBallCourtsBall) })
y2c
system.time({ y2c <- adply(1:100, 1, getBallCourtsBall) })
y2c
system.time({ y2c <- adply(1:1000, 1, getBallCourtsBall) })
system.time({ y2c <- lapply(1:1000, getBallCourtsBall) })
y2c <- data.frame(matrix(runif(4*3.5e5), nrow=)) # Try to preallocate memory
dim(y2c)
y2c <- data.frame(matrix(runif(4*3.5e5), nrow=3.5e5)) # Try to preallocate memory
y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e5)) # Try to preallocate memory
y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e6)) # Try to preallocate memory
system.time({ y2c <- adply(1:1000, 1, getBallCourtsBall) })
system.time({ y2c <- adply(1:10000, 1, getBallCourtsBall) })
system.time({ y2c <- adply(1:1000, 1, getBallCourtsBall) })
system.time({ y2c <- adply(1:1001, 1, getBallCourtsBall) })
y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e6)) # Try to preallocate memory
system.time({ y2c <- adply(1:10000, 1, getBallCourtsBall) })
y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e6)) # Try to preallocate memory
system.time({ y2c <- lapply(1:10000, getBallCourtsBall) })
y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e6)) # Try to preallocate memory
system.time({ y2c <- adply(1:nrow(youthGeo), 1, getBallCourtsBall) })
2261/60
nrow(youthGeo)
gc()
partSize <- ceiling(nrow(youthGeo) / 50)
partSize
partSize <- ceiling(nrow(youthGeo) / 50)
foreach (part in 1:50){
print(paste("Working on part", part)
bot <- part*(partSize-1)+1
top <- min(nrow(youthGeo), part*partSize)
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
for (part in 1:50){
print(paste("Working on part", part)
bot <- part*(partSize-1)+1
top <- min(nrow(youthGeo), part*partSize)
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
for (part in 1:50) {
print(paste("Working on part", part))
bot <- part*(partSize-1)+1
top <- min(nrow(youthGeo), part*partSize)
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
50*144
y2c_1
partSize <- ceiling(nrow(youthGeo) / 50)
for (part in 1:50) {
bot <- part*(partSize-1)+1
top <- min(nrow(youthGeo), part*partSize)
print(paste("Working on part", part, "-- working on obs",bot,"to","top"))
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
for (part in 1:50) {
bot <- part*(partSize-1)+1
top <- min(nrow(youthGeo), part*partSize)
print(paste("Working on part", part, "-- working on obs",bot,"to",top))
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
partSize
part <- 1
bot <- part*(partSize-1)+1
bot
bot <- partSize*(part-1)+1
bot
top <- min(nrow(youthGeo), partSize*part)
top
part <- 2
bot <- partSize*(part-1)+1
top <- min(nrow(youthGeo), partSize*part)
partSize <- ceiling(nrow(youthGeo) / 50)
for (part in 1:50) {
bot <- partSize*(part-1)+1
top <- min(nrow(youthGeo), partSize*part)
print(paste("Working on part", part, "-- working on obs",bot,"to",top))
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
y2c <- do.call("rbind", grep("y2c_", ls(), value=T))
y2c <- do.call("rbind", mget(grep("y2c_", ls(), value=T)))
head(y2c)
length(unique(y2c$y.Id))
length(unique(youthData$y.Id))
length(unique(youthGeo$y.Id))
length(unique(youthGeo$c.Id))
length(unique(y2c$c.Id))
rm(list=grep("y2c_", ls(), value=T))
cbind(unique(youthGeo$y.Id), unique(youthGeo$y.Id) %in% unique(y2c$y.Id))
tail(cbind(unique(youthGeo$y.Id), unique(youthGeo$y.Id) %in% unique(y2c$y.Id)))
save(y2c, file="./data/prepped/youth-to-court-data.Rda")
save(c2c, file="./data/prepped/court-to-court-distances.Rda")
colnames(y2c)
head(youthGeo)
nKeptCombos <- 0 # This will be used to pre-allocate a data.frame that will hold the results
getBallCourtsBall <- function(ixy, maxRad = 3.0){ # Name is a topology joke
m <- merge(x=youthGeo[ixy,], y=courtXY)
m$d <- L1Dist_DegToMi(m$Xjit, m$Yjit, m$X, m$Y)
keepCourts <- m$d < maxRad & !is.na(m$d)
nKeptCombos <<- nKeptCombos + sum(keepCourts)
return(m[keepCourts, c("y.Id", "c.Id", "pov", "d", "cr")])
}
# Attempting to get preallocate and run the single job of returning results to a data.frame. This was abandoned in favor
#   of carving up the job, since run-times here were taking too long
#   y2c <- data.frame(matrix(runif(4*3.5e6), nrow=3.5e6)) # Try to preallocate memory
#   system.time({ y2c <- adply(1:nrow(youthGeo), 1, getBallCourtsBall) }) # adply has slower runtime than lapply, but gives us output in the form that we want: a dataframe
# Trying to carve up the job into multiple parts, since run time appears to be convex in job size
partSize <- ceiling(nrow(youthGeo) / 50)
for (part in 1:50) {
bot <- partSize*(part-1)+1
top <- min(nrow(youthGeo), partSize*part)
print(paste("Working on part", part, "-- working on obs",bot,"to",top))
system.time( assign(paste0("y2c_", part), adply(bot:top, 1, getBallCourtsBall)) )
}
y2c <- do.call("rbind", mget(grep("y2c_", ls(), value=T)))
rm(list=grep("y2c_", ls(), value=T))
# Output file: youth-court matches, coded with poverty, and court-to-court distances
save(y2c, file="./data/prepped/youth-to-court-data.Rda")
save(c2c, file="./data/prepped/court-to-court-distances.Rda")
colnames(y2c)
rm(list=ls())
#library(foreign) # This allows us to import dbf files.
setwd("~/GitHub/canopy")
source("./code/run-canopy/declare-canopy-method.r")
"%&%" <- function(...){paste(..., sep="")}
#####################
# Set Run Parameters
#####################
nIter       <- 3e5
nCheckPoint <- ceiling(nIter/50) # 6e3
#############################################################
# Set Up Initialization, Objective, Neighbors and Temperature
#############################################################
load("./data/prepped/youth-to-court-data.Rda")
ny <- length(y2c)
load("./data/prepped/court-to-court-distances.Rda")
# Determine weight for youth in objective
y2c$Wgt[y2c$Pov == "n200_.FPL"  ] <- 1
y2c$Wgt[y2c$Pov == "n100_199FPL"] <- 2
y2c$Wgt[y2c$pov == "n200_.FPL"  ] <- 1
y2c$Wgt[y2c$pov == "n100_199FPL"] <- 2
y2c$Wgt[y2c$pov == "n50_99FPL"  ] <- 3
y2c$Wgt[y2c$pov == "n0_50FPL"   ] <- 4
yWgt <- unique(y[, c("y.Id", "Wgt")])
yWgt <- unique(yy2c[, c("y.Id", "Wgt")])
yWgt <- uniqueyy2c[, c("y.Id", "Wgt")])
yWgt <- unique(y2c[, c("y.Id", "Wgt")])
Alloc <- data.frame(unique(y2c$c.Id))
colnames(Alloc)[1] <- "c.Id"
Alloc$s0 <- 1 # "s" is for either "staff" or "state"
nc <- nrow(Alloc)
vLowerBound <- as.vector(rep(0, nc))
vUpperBound <- as.vector(rep(nc, nc))
Obj <- function(vStateN) {
y2c.o <- merge(x=y2c, y=vStateN, by=c.Id)
y2c.o <- within(y2c.o, eVij <- exp(1.5 + (-1.0)*d + (-0.2)*d*cr + 0.5*(s) + 1.5*runif(nrow(y2c))))
Sum.eVij <- aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T)
colnames(Sum.eVij) <- c("y.Id", "Sum.eVij")
yPr <- merge(y2c.o[, c("y.Id", "eVij")], Sum.eVij, by="y.Id")
yPr$Pr <- yPr$eVij / (1 + yPr$Sum.eVij)
# The 1 represents the normalized value of the alternative Vi0, since: 1 = exp(0)
#Sum probability that each youth plays ball
Sum.Pr <- aggregate(yPr$Pr, list(yPr$y.Id), mean, na.rm = T)
colnames(Sum.Pr) <- c("y.Id", "TotPr")
# Merge in youth objective weights and score
yPrPov <- merge(Sum.Pr, yWgt, by="y.Id")
score <- as.vector(yPrPov$TotPr) %*% as.vector(t(yPrPov$Wgt))
#hist(Sum.Pr$TotPr)
return(score)
}
Obj(Alloc$s0)
Alloc$s0
vStateN<-Alloc$s0
y2c.o <- merge(x=y2c, y=vStateN, by=c.Id)
Obj(Alloc)
vStateN <- Alloc
y2c.o <- merge(x=y2c, y=vStateN, by=c.Id)
colnames(y2c)
head(Alloc)
y2c.o <- merge(x=y2c, y=vStateN, by="c.Id")
y2c.o <- within(y2c.o, eVij <- exp(1.5 + (-1.0)*d + (-0.2)*d*cr + 0.5*(s) + 1.5*runif(nrow(y2c))))
colnames(y2c.o)
y2c.o <- within(y2c.o, eVij <- exp(1.5 + (-1.0)*d + (-0.2)*d*cr + 0.5*(s0) + 1.5*runif(nrow(y2c))))
Sum.eVij <- aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T)
colnames(Sum.eVij) <- c("y.Id", "Sum.eVij")
yPr <- merge(y2c.o[, c("y.Id", "eVij")], Sum.eVij, by="y.Id")
yPr$Pr <- yPr$eVij / (1 + yPr$Sum.eVij)
Sum.Pr <- aggregate(yPr$Pr, list(yPr$y.Id), mean, na.rm = T)
colnames(Sum.Pr) <- c("y.Id", "TotPr")
yPrPov <- merge(Sum.Pr, yWgt, by="y.Id")
score <- as.vector(yPrPov$TotPr) %*% as.vector(t(yPrPov$Wgt))
Obj <- function(vStateN) {
# Merge in staff allocation data for probability calculations
# Generate function value for each y2c combination
# Get youth probability by dividing value by sum of values by y
# Inner product between probability and scores
y2c.o <- merge(x=y2c, y=vStateN, by="c.Id")
y2c.o <- within(y2c.o, eVij <- exp(1.5 + (-1.0)*d + (-0.2)*d*cr + 0.5*(s0) + 1.5*runif(nrow(y2c))))
Sum.eVij <- aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T)
colnames(Sum.eVij) <- c("y.Id", "Sum.eVij")
yPr <- merge(y2c.o[, c("y.Id", "eVij")], Sum.eVij, by="y.Id")
yPr$Pr <- yPr$eVij / (1 + yPr$Sum.eVij)
# The 1 represents the normalized value of the alternative Vi0, since: 1 = exp(0)
#Sum probability that each youth plays ball
Sum.Pr <- aggregate(yPr$Pr, list(yPr$y.Id), mean, na.rm = T)
colnames(Sum.Pr) <- c("y.Id", "TotPr")
# Merge in youth objective weights and score
yPrPov <- merge(Sum.Pr, yWgt, by="y.Id")
score <- as.vector(yPrPov$TotPr) %*% as.vector(t(yPrPov$Wgt))
#hist(Sum.Pr$TotPr)
return(score)
}
Obj(Alloc)
Obj(Alloc)
system.time( Obj(Alloc))
Obj(Alloc)
y2c$e <- runif(nrow(y2c))
Obj <- function(vStateN) {
# Merge in staff allocation data for probability calculations
# Generate function value for each y2c combination
# Get youth probability by dividing value by sum of values by y
# Inner product between probability and scores
y2c.o <- merge(x=y2c, y=vStateN, by="c.Id")
y2c.o <- within(y2c.o, eVij <- exp(1.5 + (-1.0)*d + (-0.2)*d*cr + 0.5*(s0) + 1.5*e))
Sum.eVij <- aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T)
colnames(Sum.eVij) <- c("y.Id", "Sum.eVij")
yPr <- merge(y2c.o[, c("y.Id", "eVij")], Sum.eVij, by="y.Id")
yPr$Pr <- yPr$eVij / (1 + yPr$Sum.eVij)
# The 1 represents the normalized value of the alternative Vi0, since: 1 = exp(0)
#Sum probability that each youth plays ball
Sum.Pr <- aggregate(yPr$Pr, list(yPr$y.Id), mean, na.rm = T)
colnames(Sum.Pr) <- c("y.Id", "TotPr")
# Merge in youth objective weights and score
yPrPov <- merge(Sum.Pr, yWgt, by="y.Id")
score <- as.vector(yPrPov$TotPr) %*% as.vector(t(yPrPov$Wgt))
#hist(Sum.Pr$TotPr)
return(score)
}
Obj(Alloc)
Obj(Alloc)
aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T)
system.time( aggregate(y2c.o$eVij, list(y2c.o$y.Id), mean, na.rm = T))
system.time( tapply(y2c.o$eVij, factor(y2c.o$y.Id), mean, na.rm = T))
yOnes <- 1*(y2c$y.Id == rep(y2c$y.Id, times==ny))
yOnes <- 1*(y2c$y.Id == rep(y2c$y.Id, times=ny))
dim(yOnes)
length(yONes)
length(yOnes)
ny
ny <- nrow(y2c)
ny
yOnes <- 1*(rep(y2c$y.Id, each=ny) == rep(y2c$y.Id, times=ny))
